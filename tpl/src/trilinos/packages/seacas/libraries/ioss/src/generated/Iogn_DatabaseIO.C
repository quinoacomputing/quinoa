// Copyright(C) 1999-2010
// Sandia Corporation. Under the terms of Contract
// DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
// certain rights in this software.
//         
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
// 
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Sandia Corporation nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <generated/Iogn_DatabaseIO.h>
#include <generated/Iogn_GeneratedMesh.h>

#include <Ioss_CodeTypes.h>
#include <Ioss_SubSystem.h>
#include <Ioss_Utils.h>
#include <string>

namespace Iogn {

  // ========================================================================
  const IOFactory* IOFactory::factory()
  {
    static IOFactory registerThis;
    return &registerThis;
  }

  IOFactory::IOFactory()
    : Ioss::IOFactory("generated")
  {}

  Ioss::DatabaseIO* IOFactory::make_IO(const std::string& filename,
				       Ioss::DatabaseUsage db_usage,
				       MPI_Comm communicator,
				       const Ioss::PropertyManager &properties) const
  { return new DatabaseIO(NULL, filename, db_usage, communicator, properties); }

  // ========================================================================
  DatabaseIO::DatabaseIO(Ioss::Region *region, const std::string& filename,
			 Ioss::DatabaseUsage db_usage,
			 MPI_Comm communicator,
			 const Ioss::PropertyManager &properties) :
    Ioss::DatabaseIO(region, filename, db_usage, communicator, properties), 
    m_generatedMesh(NULL),  spatialDimension(3), nodeCount(0),
    elementCount(0), nodeBlockCount(0),
    elementBlockCount(0), nodesetCount(0), sidesetCount(0),
    sequentialNG2L(false), sequentialEG2L(false)
  {
    if (is_input()) {
      dbState = Ioss::STATE_UNKNOWN;
    } else {
      std::ostringstream errmsg;
      errmsg << "Generated mesh option is only valid for input mesh.";
      IOSS_ERROR(errmsg);
    }
  }

  DatabaseIO::~DatabaseIO()
  {
    delete m_generatedMesh;
  }

  void DatabaseIO::read_meta_data()
  {
    m_generatedMesh = new GeneratedMesh(get_filename(), util().parallel_size(), util().parallel_rank());

    spatialDimension = 3;
    nodeCount = m_generatedMesh->node_count_proc();
    elementCount = m_generatedMesh->element_count_proc();
    elementBlockCount =  m_generatedMesh->block_count();
    nodesetCount = m_generatedMesh->nodeset_count();
    sidesetCount = m_generatedMesh->sideset_count();
    
    get_nodeblocks();
    get_elemblocks();
    get_nodesets();
    get_sidesets();
    get_commsets();
    
    Ioss::Region *this_region = get_region();
    this_region->property_add(Ioss::Property(std::string("title"), std::string("GeneratedMesh: ") += get_filename()));
    this_region->property_add(Ioss::Property(std::string("spatial_dimension"), 3));
  }

  bool DatabaseIO::begin(Ioss::State /* state */)
  {
    return true;
  }

  bool   DatabaseIO::end(Ioss::State /* state */)
  {
    return true;
  }

  bool DatabaseIO::begin_state(Ioss::Region *region, int /* state */, double time )
  {
    return true;
  }

  bool   DatabaseIO::end_state(Ioss::Region */* region */, int /* state */, double /* time */)
  {
    return true;
  }

  int64_t DatabaseIO::get_field_internal(const Ioss::NodeBlock* nb,
				     const Ioss::Field& field,
				     void *data, size_t data_size) const
  {
    size_t num_to_get = field.verify(data_size);
    if (num_to_get > 0) {

      Ioss::Field::RoleType role = field.get_role();
      if (role == Ioss::Field::MESH) {
	if (field.get_name() == "mesh_model_coordinates") {
	  // Cast 'data' to correct size -- double
	  double *rdata = static_cast<double*>(data);
	  m_generatedMesh->coordinates(rdata);
	}

	else if (field.get_name() == "ids") {
	  // Map the local ids in this node block
	  // (1...node_count) to global node ids.
	  const Ioss::MapContainer &map = get_node_map();
	  if (field.is_type(Ioss::Field::INTEGER)) {
	    int *ids = static_cast<int*>(data);
	    
	    for (size_t i=0; i < num_to_get; i++) {
	      ids[i] = map[1 + i];
	    }
	  } else {
	    int64_t *ids = static_cast<int64_t*>(data);
	    
	    for (size_t i=0; i < num_to_get; i++) {
	      ids[i] = map[1 + i];
	    }
	  }
	}
	else if (field.get_name() == "connectivity") {
	  // Do nothing, just handles an idiosyncracy of the GroupingEntity
	}
	else if (field.get_name() == "connectivity_raw") {
	  // Do nothing, just handles an idiosyncracy of the GroupingEntity
	}
	else {
	  num_to_get = Ioss::Utils::field_warning(nb, field, "input");
	}
	return num_to_get;
      } else {
	num_to_get = Ioss::Utils::field_warning(nb, field, "input");
      }
    }
    return num_to_get;
  }

  int64_t DatabaseIO::get_field_internal(const Ioss::Region* /* reg */, const Ioss::Field& /* field */,
				     void */* data */, size_t /* data_size */) const
  {
    return -1;
  }

  int64_t DatabaseIO::get_field_internal(const Ioss::ElementBlock* eb, const Ioss::Field& field,
				     void *data, size_t data_size) const
  {
    size_t num_to_get = field.verify(data_size);
    if (num_to_get > 0) {

      int64_t id = eb->get_property("id").get_int();
      int64_t element_count = eb->get_property("entity_count").get_int();
      Ioss::Field::RoleType role = field.get_role();

      if (role == Ioss::Field::MESH) {
	// Handle the MESH fields required for an ExodusII file model.
	// (The 'genesis' portion)

	if (field.get_name() == "connectivity" || field.get_name() == "connectivity_raw") {
	  assert(field.raw_storage()->component_count() == m_generatedMesh->topology_type(id).second);

	  // The generated mesh connectivity is returned in a vector.  Ids are global
	  if (field.is_type(Ioss::Field::INTEGER)) {
	    int *connect = static_cast<int*>(data);
	    m_generatedMesh->connectivity(id, connect);
	  } else {
	    int64_t *connect = static_cast<int64_t*>(data);
	    m_generatedMesh->connectivity(id, connect);
	  }
	}
	else if (field.get_name() == "ids") {
	  // Map the local ids in this element block
	  // (eb_offset+1...eb_offset+1+element_count) to global element ids.
	  const Ioss::MapContainer &map = get_element_map();
	  int64_t eb_offset = eb->get_offset();
	  if (field.is_type(Ioss::Field::INTEGER)) {
	    int *ids = static_cast<int*>(data);
	    for (size_t i=0; i < num_to_get; i++) {
	      ids[i] = map[eb_offset + 1 + i];
	    }
	  } else {
	    int64_t*ids = static_cast<int64_t*>(data);
	    for (size_t i=0; i < num_to_get; i++) {
	      ids[i] = map[eb_offset + 1 + i];
	    }
	  }
	}
	else {
	  num_to_get = Ioss::Utils::field_warning(eb, field, "input");
	}
      }

      else if (role == Ioss::Field::ATTRIBUTE) {
	if (element_count > 0) {
	  int attribute_count = eb->get_property("attribute_count").get_int();
	  if (attribute_count > 0) {
	    double *attr = static_cast<double*>(data);
	    for (size_t i=0; i < num_to_get; i++) {
	      attr[i] = 1.0;
	    }
	  }
	}
      }

      else if (role == Ioss::Field::TRANSIENT) {
	// Check if the specified field exists on this element block.
	// Note that 'higher-order' storage types (e.g. SYM_TENSOR)
	// exist on the database as scalars with the appropriate
	// extensions.

	// Read in each component of the variable and transfer into
	// 'data'.  Need temporary storage area of size 'number of
	// elements in this block.
	num_to_get = Ioss::Utils::field_warning(eb, field, "transient");
      } else if (role == Ioss::Field::REDUCTION) {
	num_to_get = Ioss::Utils::field_warning(eb, field, "input reduction");
      }
    }
    return num_to_get;
  }

  int64_t DatabaseIO::get_field_internal(const Ioss::SideBlock* ef_blk,
				     const Ioss::Field& field,
				     void *data, size_t data_size) const
  {
    size_t num_to_get = field.verify(data_size);
    if (num_to_get > 0) {

      int64_t id = ef_blk->get_property("id").get_int();
      size_t entity_count = ef_blk->get_property("entity_count").get_int();
      if (num_to_get != entity_count) {
	std::ostringstream errmsg;
	errmsg << "Partial field input not implemented for side blocks";
	IOSS_ERROR(errmsg);
      }

      Ioss::Field::RoleType role = field.get_role();
      if (role == Ioss::Field::MESH) {

	if (field.get_name() == "ids") {
	  // A sideset' is basically an exodus sideset.  A
	  // sideset has a list of elements and a corresponding local
	  // element side (1-based) The side id is: side_id =
	  // 10*element_id + local_side_number This assumes that all
	  // sides in a sideset are boundary sides.
	  std::vector<int64_t> elem_side;
	  m_generatedMesh->sideset_elem_sides(id, elem_side);
	  if (field.is_type(Ioss::Field::INTEGER)) {
	    int *ids = static_cast<int*>(data);
	    for (size_t i=0; i < num_to_get; i++) {
	      ids[i] = 10 * elem_side[2*i+0] + elem_side[2*i+1] + 1;
	    }
	  } else {
	    int64_t *ids = static_cast<int64_t*>(data);
	    for (size_t i=0; i < num_to_get; i++) {
	      ids[i] = 10 * elem_side[2*i+0] + elem_side[2*i+1] + 1;
	    }
	  }
	}

	else if (field.get_name() == "element_side" ||
		 field.get_name() == "element_side_raw") {
	  // Since we only have a single array, we need to allocate an extra
	  // array to store all of the data.  Note also that the element_id
	  // is the global id but only the local id is stored so we need to
	  // map from local_to_global prior to generating the side id...

	  std::vector<int64_t> elem_side;
	  m_generatedMesh->sideset_elem_sides(id, elem_side);

	  if (field.is_type(Ioss::Field::INTEGER)) {
	    int *element_side = static_cast<int*>(data);
	    for (size_t i=0; i < num_to_get; i++) {
	      element_side[2*i+0] = elem_side[2*i+0];
	      element_side[2*i+1] = elem_side[2*i+1] + 1;
	    }
	  } else {
	    int64_t *element_side = static_cast<int64_t*>(data);
	    for (size_t i=0; i < num_to_get; i++) {
	      element_side[2*i+0] = elem_side[2*i+0];
	      element_side[2*i+1] = elem_side[2*i+1] + 1;
	    }
	  }
	}

	else if (field.get_name() == "distribution_factors") {
	  double *dist_fact = static_cast<double*>(data);
	  size_t comp_count = ef_blk->get_field("distribution_factors").transformed_storage()->component_count();
	  for (size_t i=0; i < num_to_get * comp_count; i++) {
	    dist_fact[i] = 1.0;
	  }
	}

	else {
	  num_to_get = Ioss::Utils::field_warning(ef_blk, field, "input");
	}
      } else if (role == Ioss::Field::TRANSIENT) {
	num_to_get = Ioss::Utils::field_warning(ef_blk, field, "transient");
      }
    }
    return num_to_get;
  }

  int64_t DatabaseIO::get_field_internal(const Ioss::NodeSet* ns,
				     const Ioss::Field& field,
				     void *data, size_t data_size) const
  {
    size_t num_to_get = field.verify(data_size);
    if (num_to_get > 0) {

      int64_t id = ns->get_property("id").get_int();
      Ioss::Field::RoleType role = field.get_role();
      if (role == Ioss::Field::MESH) {

	if (field.get_name() == "ids" ||
	    field.get_name() == "ids_raw") {
	  std::vector<int64_t> nodes;
	  m_generatedMesh->nodeset_nodes(id, nodes);
	  if (field.is_type(Ioss::Field::INTEGER)) {
	    int *ids = static_cast<int*>(data);
	    std::copy(nodes.begin(), nodes.end(), ids);
	  } else {
	    int64_t *ids = static_cast<int64_t*>(data);
	    std::copy(nodes.begin(), nodes.end(), ids);
	  }
	} else if (field.get_name() == "distribution_factors") {
	  double *rdata = static_cast<double*>(data);
	  for (size_t i=0; i < num_to_get; i++)
	    rdata[i] = 1.0;
	} else {
	  num_to_get = Ioss::Utils::field_warning(ns, field, "input");
	}
      } else if (role == Ioss::Field::TRANSIENT) {
	num_to_get = Ioss::Utils::field_warning(ns, field, "transient");
      }
    }
    return num_to_get;
  }
    
  int64_t DatabaseIO::get_field_internal(const Ioss::EdgeBlock* /* fs */, const Ioss::Field& /* field */,
				     void */* data */, size_t /* data_size */) const
  {
    return -1;
  }
  int64_t DatabaseIO::get_field_internal(const Ioss::FaceBlock* /* fs */, const Ioss::Field& /* field */,
				     void */* data */, size_t /* data_size */) const
  {
    return -1;
  }
  int64_t DatabaseIO::get_field_internal(const Ioss::EdgeSet* /* fs */, const Ioss::Field& /* field */,
				     void */* data */, size_t /* data_size */) const
  {
    return -1;
  }
  int64_t DatabaseIO::get_field_internal(const Ioss::FaceSet* /* fs */, const Ioss::Field& /* field */,
				     void */* data */, size_t /* data_size */) const
  {
    return -1;
  }
  int64_t DatabaseIO::get_field_internal(const Ioss::ElementSet* /* fs */, const Ioss::Field& /* field */,
				     void */* data */, size_t /* data_size */) const
  {
    return -1;
  }

  int64_t DatabaseIO::get_field_internal(const Ioss::SideSet* /* fs */, const Ioss::Field& /* field */,
				     void */* data */, size_t /* data_size */) const
  {
    return -1;
  }
  int64_t DatabaseIO::get_field_internal(const Ioss::CommSet* cs, const Ioss::Field& field,
				     void *data, size_t data_size) const
  {
    size_t num_to_get = field.verify(data_size);

    if (num_to_get > 0) {
      size_t entity_count = cs->get_property("entity_count").get_int();

      // Return the <entity (node or face), processor> pair
      if (field.get_name() == "entity_processor") {

	// Check type -- node or face
	std::string type = cs->get_property("entity_type").get_string();

	if (type == "node") {
	  // Allocate temporary storage space
	  Ioss::Int64Vector entities(num_to_get);
	  Ioss::IntVector procs(num_to_get);
	  m_generatedMesh->node_communication_map(entities, procs);
	  
	  // and store in 'data' ...
	  if (field.is_type(Ioss::Field::INTEGER)) {
	    int* entity_proc = static_cast<int*>(data);
	    
	    size_t j=0;
	    for (size_t i=0; i < entity_count; i++) {
	      entity_proc[j++] = entities[i];
	      entity_proc[j++] = procs[i];
	    }
	  } else {
	    int64_t* entity_proc = static_cast<int64_t*>(data);
	    
	    size_t j=0;
	    for (size_t i=0; i < entity_count; i++) {
	      entity_proc[j++] = entities[i];
	      entity_proc[j++] = procs[i];
	    }
	  }
	} else {
	  std::ostringstream errmsg;
	  errmsg << "Invalid commset type " << type;
	  IOSS_ERROR(errmsg);
	}

      } else if (field.get_name() == "ids") {
	// Do nothing, just handles an idiosyncracy of the GroupingEntity
      } else {
	num_to_get = Ioss::Utils::field_warning(cs, field, "input");
      }
    }
    return num_to_get;
  }

  // Input only database -- these will never be called...
  int64_t DatabaseIO::put_field_internal(const Ioss::Region*,      const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::ElementBlock*,const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::FaceBlock*,const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::EdgeBlock*,const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::NodeBlock*,   const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::ElementSet*,     const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::FaceSet*,     const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::EdgeSet*,     const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::NodeSet*,     const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::SideSet*,     const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::SideBlock*,   const Ioss::Field&, void*, size_t) const {return -1;}
  int64_t DatabaseIO::put_field_internal(const Ioss::CommSet*,     const Ioss::Field&, void*, size_t) const {return -1;}

  const Ioss::MapContainer& DatabaseIO::get_node_map() const
  {
    // Allocate space for node number map and read it in...
    // Can be called multiple times, allocate 1 time only
    if (nodeMap.empty()) {
      nodeMap.resize(nodeCount+1);

      if (is_input()) {
	std::vector<int64_t> map;
	m_generatedMesh->node_map(map);

	// Map needed for Ioss starts at position 1 since the
	// sequential/non-sequential flag is at position 0...
	std::copy(map.begin(), map.end(), &nodeMap[1]);

	// Check for sequential node map.
	// If not, build the reverse G2L node map...
	sequentialNG2L = true;
	for (int64_t i=1; i < nodeCount+1; i++) {
	  if (i != nodeMap[i]) {
	    sequentialNG2L = false;
	    nodeMap[0] = 1;
	    break;
	  }
	}

	if (!sequentialNG2L) {
	  Ioss::Map::build_reverse_map(&reverseNodeMap,
				       &nodeMap[1], nodeCount, 0,
				       "node", myProcessor);
	} else {
	  // Sequential map
	  sequentialNG2L = true;
	  nodeMap[0] = -1;
	}

      } else {
	// Output database; nodeMap not set yet... Build a default map.
	for (int64_t i=1; i < nodeCount+1; i++) {
	  nodeMap[i] = i;
	}
	// Sequential map
	sequentialNG2L = true;
	nodeMap[0] = -1;
      }
    }
    return nodeMap;
  }

  const Ioss::MapContainer& DatabaseIO::get_element_map() const
  {
    // Allocate space for elemente number map and read it in...
    // Can be called multiple times, allocate 1 time only
    if (elementMap.empty()) {
      elementMap.resize(elementCount+1);

      if (is_input()) {
	std::vector<int64_t> map;
	m_generatedMesh->element_map(map);

	// Map needed for Ioss starts at position 1 since the
	// sequential/non-sequential flag is at position 0...
	std::copy(map.begin(), map.end(), &elementMap[1]);

	// Check for sequential element map.
	// If not, build the reverse G2L element map...
	sequentialEG2L = true;
	for (int64_t i=1; i < elementCount+1; i++) {
	  if (i != elementMap[i]) {
	    sequentialEG2L = false;
	    elementMap[0] = 1;
	    break;
	  }
	}

	if (!sequentialEG2L) {
	  Ioss::Map::build_reverse_map(&reverseElementMap,
				       &elementMap[1], elementCount, 0,
				       "element", myProcessor);
	} else {
	  // Sequential map
	  sequentialEG2L = true;
	  elementMap[0] = -1;
	}

      } else {
	// Output database; elementMap not set yet... Build a default map.
	for (int64_t i=1; i < elementCount+1; i++) {
	  elementMap[i] = i;
	}
	// Sequential map
	sequentialEG2L = true;
	elementMap[0] = -1;
      }
    }
    return elementMap;
  }

  void DatabaseIO::get_nodeblocks()
  {
    std::string block_name = "nodeblock_1";
    Ioss::NodeBlock *block = new Ioss::NodeBlock(this, block_name,
						 m_generatedMesh->node_count_proc(), 3);
    block->property_add(Ioss::Property("id", 1));
    get_region()->add(block);
  }

  void DatabaseIO::get_elemblocks()
  {
    // Attributes of an element block are:
    // -- id
    // -- name
    // -- element type
    // -- number of elements
    // -- number of attributes per element
    // -- number of nodes per element (derivable from type)
    // -- number of faces per element (derivable from type)
    // -- number of edges per element (derivable from type)

    int block_count = m_generatedMesh->block_count();
    for (int i=0; i < block_count; i++) {
      std::string name = Ioss::Utils::encode_entity_name("block", i+1);
      std::string type = m_generatedMesh->topology_type(i+1).first;
      size_t element_count =  m_generatedMesh->element_count_proc(i+1);
      Ioss::ElementBlock *block = new Ioss::ElementBlock(this, name, type, element_count);

      block->property_add(Ioss::Property("id", i+1));
      
      // Maintain block order on output database...
      block->property_add(Ioss::Property("original_block_order", i));
      block->property_add(Ioss::Property("global_entity_count", (int64_t)m_generatedMesh->element_count(i+1)));
      
      int attribute_count = i == 0 ? 0 : 1;
      if (attribute_count > 0) {
	block->field_add(Ioss::Field("thickness", Ioss::Field::REAL, "scalar", Ioss::Field::ATTRIBUTE,
				     (int64_t)m_generatedMesh->element_count_proc(i+1)));
      }
      
      get_region()->add(block);
    }
  }

  void DatabaseIO::get_nodesets()
  {
    // Attributes of a nodeset are:
    // -- id
    // -- name
    // -- number of nodes
    // -- number of distribution factors (see next comment)
    // ----the #distribution factors should equal #nodes or 0, any
    //     other value does not make sense. If it is 0, then a substitute
    //     list will be created returning 1.0 for the factor

    // In a parallel execution, it is possible that a nodeset will have
    // no nodes or distribution factors on a particular processor...

    // Get nodeset metadata
    for (int ins = 0; ins < nodesetCount; ins++) {
      int64_t number_nodes = m_generatedMesh->nodeset_node_count_proc(ins+1);
      
      std::string name = Ioss::Utils::encode_entity_name("nodelist", ins+1);
      Ioss::NodeSet *nodeset = new Ioss::NodeSet(this, name, number_nodes);
      nodeset->property_add(Ioss::Property("id", ins+1));
      get_region()->add(nodeset);
    }
  }

  void DatabaseIO::get_sidesets()
  {
    m_sideset_names.reserve(sidesetCount);
    for (int ifs = 0; ifs < sidesetCount; ifs++) {
      std::string name = Ioss::Utils::encode_entity_name("surface", ifs+1);
      m_sideset_names.push_back(name);
      Ioss::SideSet *sideset = new Ioss::SideSet(this, name);
      sideset->property_add(Ioss::Property("id", ifs+1));
      get_region()->add(sideset);

      std::string ef_block_name = name + "_quad4";
      std::string side_topo_name = "quad4";
      std::string elem_topo_name = "unknown";
      int64_t number_faces = m_generatedMesh->sideset_side_count_proc(ifs+1);

      Ioss::SideBlock *ef_block = new Ioss::SideBlock(this, ef_block_name,
						      side_topo_name,
						      elem_topo_name,
						      number_faces);
      sideset->add(ef_block);
      ef_block->property_add(Ioss::Property("id", ifs+1));

      std::string storage = "Real[";
      storage += Ioss::Utils::to_string(4);
      storage += "]";
      ef_block->field_add(Ioss::Field("distribution_factors",
				      Ioss::Field::REAL, storage,
				      Ioss::Field::MESH, number_faces));
    }
  }

  void DatabaseIO::get_commsets()
  {
    if (util().parallel_size() > 1) {
      // Get size of communication map...
      size_t my_node_count = m_generatedMesh->communication_node_count_proc();
	
      // Create a single node commset 
      Ioss::CommSet *commset = new Ioss::CommSet(this, "commset_node", "node", my_node_count);
      commset->property_add(Ioss::Property("id", 1));
      get_region()->add(commset);
    }
  }

  unsigned DatabaseIO::entity_field_support() const
  {
    return Ioss::NODEBLOCK | Ioss::ELEMENTBLOCK | Ioss::REGION;
  }

}
