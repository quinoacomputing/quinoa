<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
</head>
<body>
<h2>Large model modifications to the exodusII library:</h2>
<pre>The changes are to support the storage of larger models. There are two<br>pieces of this. The first is the setting of the type of netcdf file<br>that will be created; either one with 32-bit offsets or one with<br>64-bit offsets. This can be specified in a couple ways:<br><br>1. Pass the EX_LARGE_MODEL flag in the mode argument to ex_create.<br>2. Set the environment variable EXODUS_LARGE_MODEL.<br><br>If either of these are set, then the library will pass the<br>NC_64BIT_OFFSET flag to the netcdf library. See the commit log for<br>netcdf library for more details.<br><br>The other change is to reduce the size of some of the datasets in an<br>exodusII library. Even with the netcdf changes, the maximum dataset<br>size is still 2GB. To reduce the size of the datasets, the nodal<br>coordinates and the nodal variables have been split to store by<br>component. The old behavior stored all x, y, and z coordinates in a<br>single dataset; in the new behavior, each component is stored<br>separately -- there is a coordx, coordy, and coordz dataset.<br><br>The nodal variables used to be stored in a single blob of dimension<br>(#times,#nodes,#variables). This has now been split into #variable<br>datasets of size (#times,#nodes).<br><br>These two changes should increase the maximum model sizes<br>significantly. Prior to the change, the maximum number of nodes that<br>could be stored in the coordinate dataset was about 90 Million nodes;<br>the new storage permits 270 Million nodes in double precision. The old<br>model was more restrictive if there were multiple nodal variables, but<br>the new storage should not depend on the number of nodal variables.<br><br>These changes were made such that the new library would create<br>old-style files by default and would read either old or new style<br>files. The version has been changed to 3.01 for the file version and<br>4.01 for the API version.<br><br>An additional attribute is now written to the file. It is called<br>"file_size" or ATT_FILESIZE. If it is 0 or not present, then the old<br>format is assumed; if it is 1, then the new format is assumed.<br><br>There is also a new internal function called ex_large_model(int exoid)<br>which will return 1 if new version; 0 if old version.<br><br>If the function is passed a negative exoid, then it will check the<br>environment variable "EXODUS_LARGE_MODEL" and return 1 if it is<br>defined. It also currently prints a warning message saying that the<br>large model size was selected via the environment variable.<br><br>If you are using the exodusII api, then the only change to the client<br>application is the passing of the EX_LARGE_MODEL flag to ex_create or<br>the setting of the EXODUS_LARGE_MODEL environment variable. If your<br>client application is reading the database, no changes are needed.<br><br>========================================================================<br>If your client application bypasses some or all of the exodusII API<br>and makes direct netcdf calls, you will need to modify the calls.  The<br>changes that were made are shown below along with the name of the<br>exodusII API function in which the changes were made. <br><br>Alternatively, you can look at the changes that were made to the API at <br><a
 href="http://jal.sandia.gov/cgi-bin/cvsweb/ACCESS/libraries/exodusii/cbind/src">http://jal.sandia.gov/cgi-bin/cvsweb/ACCESS/libraries/exodusii/cbind/src</a>.<br>The files that were changed are:<br><br>   exgnvt.c 	  1.12 <br>   expcor.c 	  1.12 <br>   expini.c 	  1.23 <br>   expnv.c 	  1.13 <br>   expvp.c 	  1.16 <br>   expvpc.c 	  1.4 <br>   ex_utils.c 	  1.33 	<br>   excopy.c 	  1.13 	<br>   excre.c 	  1.23 	<br>   exgcor.c 	  1.13 	<br>   exgnv.c 	  1.11 	<br><br><br><b>ex_create:</b><br>-- Check whether the EX_LARGE_MODEL mode was set.  If so, then the<br>mode passed to nccreate must have the NC_64BIT_OFFSET bit set.  For<br>example, "mode |= NC_64BIT_OFFSET;"<br><br>  NOTE: NC_64BIT_OFFSET is defined in the Sandia's netcdf version <br>        "3.4-snl10X".  It should also be in netcdf-3.6.0 once it is released.<br><br>-- Write the exodus file size "ATT_FILESIZE" attribute (1=large, 0=normal):<br><br>   filesiz = (nclong)(((cmode &amp; EX_LARGE_MODEL) != 0) || (ex_large_model(-1) == 1));<br>   if (ncattput (exoid, NC_GLOBAL, ATT_FILESIZE, NC_LONG, 1, &amp;filesiz) == -1)<br>    ... handle errors...<br><br><span
 style="font-weight: bold;">ex_put_init:</span><br>-- If writing a "large model" capable database, then the coordinates<br>are defined as components instead of an array.  The variables are<br>VAR_COORD_X, VAR_COORD_Y (if 2D or 3D), VAR_COORD_Z (if 3D). If not,<br>define the VAR_COORD variable as is currently done.<br><br>     if (ex_large_model(exoid) == 1) {<br>       /* node coordinate arrays -- separate storage... */<br>       dim[0] = numnoddim;<br>       if (ncvardef (exoid, VAR_COORD_X, nc_flt_code(exoid), 1, dim) == -1)<br>	 { ... handle error }<br>       <br>       if (num_dim &gt; 1) {<br>	 if (ncvardef (exoid, VAR_COORD_Y, nc_flt_code(exoid), 1, dim) == -1)<br>	   { ... handle error }<br>       }<br>       <br>       if (num_dim &gt; 2) {<br>	 if (ncvardef (exoid, VAR_COORD_Z, nc_flt_code(exoid), 1, dim) == -1)<br>	   { ... handle error }<br>       }<br>     } else {<br>       /* node coordinate arrays: -- all stored together (old method) */<br>       .... define the old way...<br>     }       <br><br><span
 style="font-weight: bold;">ex_put_coord:</span><br>-- If writing a "large model" capable database, then the coordinates<br>are written a component at a time, otherwise write the old way as a single blob.<br>  <br>  if (ex_large_model(exoid) == 0) {<br>    ... write coordinates old way...<br>  } else {<br>    if ((coordidx = ncvarid (exoid, VAR_COORD_X)) == -1)<br>      { ... handle error }<br>    <br>    if (num_dim &gt; 1) {<br>      if ((coordidy = ncvarid (exoid, VAR_COORD_Y)) == -1)<br>	{ ... handle error }<br>    } else {<br>      coordidy = 0;<br>    }<br>    if (num_dim &gt; 2) {<br>      if ((coordidz = ncvarid (exoid, VAR_COORD_Z)) == -1)<br>	{ ... handle error }<br>    } else {<br>      coordidz = 0;<br>    }<br>    /* write out the coordinates  */<br>    for (i=0; i<num_dim
 ;="" i="" {="" if="" (i="=" 0="" coor="x_coor;" coordid="coordidx;"
 }="" else="" 1="" 2="" (nc_flt_code(exoid="=" nc_float=""
 status="nc_put_var_float(exoid," ex_conv_array(exoid,write_convert=""
 coor,(int)num_nod="" .="" check="" and="" handle="" error=""
 ex_put_var_param="" -="" there="" are="" two="" ways="" to="" store=""
 the="" nodal="" variables="" old="" way="" was="" a="" blob=""
 (#times,#vars,#nodes="" but="" that="" exceeding="" netcdf=""
 maximum="" dataset="" size="" for="" large="" models="" new="" is=""
 #vars="" separate="" datasets="" each="" of="" (#times,#nodes=""
 where="" #times="" unlimited="" dimension="" this="" very="" similar=""
 method="" used="" element="" we="" want="" routine="" be="" capable=""
 storing="" both="" formats="" based="" on="" ex_large_model=""
 setting="" ...define="" variable="" named="" vals_node_var_x="" x=""
 an="" integer="" 1..number_nodal_vars="" (ex_large_model(exoid="=" *=""
 int="">&lt;= num_vars; i++) {<br>      dims[0] = time_dim;<br>      dims[1] = num_nod_dim;<br>      if ((ncvardef (exoid, VAR_NOD_VAR_NEW(i),<br>		     nc_flt_code(exoid), 2, dims)) == -1)<br>	{  ... handle error ...	}<br>    }<br>  }<br><br
 style="font-weight: bold;"><span style="font-weight: bold;">ex_put_nodal_var:</span><br> -- If the large model method, write the nodal variable data to the correct variable;<br>    if the old method, determine the location within the blob<br><br>   if (ex_large_model(exoid) == 0) {<br>     /* write values of the nodal variable */<br>     if ((varid = ncvarid (exoid, VAR_NOD_VAR)) == -1) {<br>       ... handle error...<br>     }<br>     start[0] = --time_step;<br>     start[1] = --nodal_var_index;<br>     start[2] = 0;<br>     <br>     count[0] = 1;<br>     count[1] = 1;<br>     count[2] = num_nodes;<br>   } else {<br>     /* nodal variables stored separately, find variable for this variable<br>	index */<br>     if ((varid = ncvarid (exoid, VAR_NOD_VAR_NEW(nodal_var_index))) == -1) {<br>       ... handle error ...<br>     }<br>       <br>     start[0] = --time_step;<br>     start[1] = 0;<br><br>     count[0] = 1;<br>     count[1] = num_nodes;<br>   }<br> <br>   if (ncvarput (exoid, varid, start, count,<br>		 ex_conv_array(exoid,WRITE_CONVERT,nodal_var_vals,num_nodes)) == -1) {<br>     ...handle error ...<br>   }<br><br></num_dim></pre>
<hr style="width: 100%; height: 2px;">There are similar modifcations to
the reading of the nodal coordinates<br>
and the reading of nodal variables. If interested in those functions,
see the viewcvs URL <br>
listed above.<br>
<pre><num_dim ;="" i="" {="" if="" (i="=" 0="" coor="x_coor;"
 coordid="coordidx;" }="" else="" 1="" 2="" (nc_flt_code(exoid="="
 nc_float="" status="nc_put_var_float(exoid,"
 ex_conv_array(exoid,write_convert="" coor,(int)num_nod="" .="" check=""
 and="" handle="" error="" ex_put_var_param="" -="" there="" are=""
 two="" ways="" to="" store="" the="" nodal="" variables="" old=""
 way="" was="" a="" blob="" (#times,#vars,#nodes="" but="" that=""
 exceeding="" netcdf="" maximum="" dataset="" size="" for="" large=""
 models="" new="" is="" #vars="" separate="" datasets="" each="" of=""
 (#times,#nodes="" where="" #times="" unlimited="" dimension="" this=""
 very="" similar="" method="" used="" element="" we="" want=""
 routine="" be="" capable="" storing="" both="" formats="" based=""
 on="" ex_large_model="" setting="" ...define="" variable="" named=""
 vals_node_var_x="" x="" an="" integer="" 1..number_nodal_vars=""
 (ex_large_model(exoid="=" *="" int=""><br>If there are any questions, contact:<br>  Greg Sjaardema<br>  gdsjaar@sandia.gov<br>  505-844-2701<br><br></num_dim></pre>
</body>
</html>
