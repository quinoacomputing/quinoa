<html><head><title>VTK File Formats</title></head>
<body bgcolor=white text=202020
 link=404080 alink=406080 vlink=804080
 style="font-family:helvetica,arial; font-size:9pt;">

<br>
<p align=right>
<img src=vtkbook.jpg><br>
<br>
<b>VTK File Formats </b><i>for VTK Version 4. 2 <br>
Taken from </i>The VTK User's Guide <br>
<i>Contact Kitware <a href=http:://www.kitware.com>Kitware</a> to purchase,<br>or visit <a href=http://www.amazon.com/exec/obidos/tg/detail/-/1930934084/qid=1095198377/sr=8-1/ref=pd_ksr_1/002-6642579-8434405?v=glance&s=books&n=507846>Amazon</a>.com 72$<br>
</i>
</p>
<p>
<br><br>
<b>VTK File Formats <br>
<dir>
</b>The <i>Visualization Toolkit </i>provides a number of source and writer objects to read and write popular data file formats. The
<i>Visualization Toolkit </i>also provides some of its own file formats. The main reason for creating yet another data file format
is to offer a consistent data representation scheme for a variety of
dataset types, and to provide a simple method to com-municate
data between software. Whenever possible, we recommend that you use formats that are more widely used. But
if this is not possible, the <i>Visualization Toolkit </i>formats described here can be used instead. Note that these formats may not
be supported by many other tools. <br>
<br>
There are two different styles of file formats available in VTK. The simplest are the legacy, serial formats that are
easy to read and write either by hand or programmatically. However, these formats are less flexible than the XML based
file formats described later in this section. The XML formats support
random access, parallel I/ O, and portable data com-pression
and are preferred to the serial VTK file formats whenever possible. <br>
</p><p>
<b>Simple Legacy Formats <br>
<dir>
</b>The legacy VTK file formats consist of five basic parts. <br>
</p>
<ol>
<p>
<b>1. </b>The first part is the file version and identifier. This part contains the single line: <tt># vtk DataFile Version x. x. <br>
</tt>This line must be exactly as shown with the exception of the version number <tt>x. x, </tt>which will vary with different <br>
releases of VTK. (Note: the current version number is 3. 0. Version 1.0 and 2. 0 files are compatible with version 3. 0 <br>
files.) <br>
</p><p>
<b>2. </b>The second part is the header. The header consists of a character string terminated by end-of-line character <tt>\n. </tt>The <br>
header is 256 characters maximum. The header can be used to describe the data and include any other pertinent <br>
information. <br>
</p><p>
<b>3. </b>The next part is the file format. The file format describes the type of file, either ASCII or binary. On this line the sin-gle <br>
word <tt>ASCII </tt>or <tt>BINARY </tt>must appear. <br>
</p><p>
<b>4. </b>The fourth part is the dataset structure. The geometry part describes the geometry and topology of the dataset. This <br>
part begins with a line containing the keyword <tt>DATASET </tt>followed by a keyword describing the type of dataset. <br>
Then, depending upon the type of dataset, other keyword/ data combinations define the actual data. <br>
</p><p>
<b>5. </b>The final part describes the dataset attributes. This part begins with the keywords <tt>POINT_ DATA </tt>or <tt>CELL_ DATA, </tt>followed <br>
by an integer number specifying the number of points or cells, respectively. (It doesn't matter whether <br>
<tt>POINT_ DATA </tt>or <tt>CELL_ DATA </tt>comes first.) Other keyword/ data combinations then define the actual dataset attribute <br>
values (i. e., scalars, vectors, tensors, normals, texture coordinates, or field data). <br>
</p>
</ol>
<p>
An overview of the file format is shown in <b>Figure 1. </b>The first three parts are mandatory, but the other two are optional. <br>
Thus you have the flexibility of mixing and matching dataset attributes and geometry, either by operating system file <br>
manipulation or using VTK filters to merge data. Keywords are case insensitive, and may be separated by whitespace. <br>
Before describing the data file formats please note the following. <br>
</p>
<ul>
<p>
<b>° </b><i>dataType </i>is one of the types <tt>bit, unsigned_ char, char, unsigned_ short, short, unsigned_ int, int, <br>
unsigned_ long, long, float, </tt>ordouble. These keywords are used to describe the form of the data, both for <br>
reading from file, as well as constructing the appropriate internal objects. Not all data types are supported for all <br>
classes. 
<br>
<b>° </b>All keyword phrases are written in ASCII form whether the file is binary or ASCII. The binary section of the file (if <br>
in binary form) is the data proper; i. e., the numbers that define points coordinates, scalars, cell indices, and so forth. <br>
</p><p>
<b>° </b>Indices are 0-offset. Thus the first point is point id 0. <br>
<b>° </b>If both the data attribute and geometry/ topology part are present in the file, then the number of data values defined <br>
in the data attribute part must exactly match the number of points or cells defined in the geometry/ topology part. <br>
</p><p>
<b>° </b>Cell types and indices are of type <tt>int. <br>
</tt><b>° </b>Binary data must be placed into the file immediately after the "newline" (\ <tt>n) </tt>character from the previous ASCII <br>
keyword and parameter sequence. <br>
</p><p>
<b>° </b>The geometry/ topology description must occur prior to the data attribute description. <br>
</p>
</ul>
<p>
<b>Binary Files. </b>Binary files in VTK are portable across different computer systems as long as you observe two conditions. <br>
First, make sure that the byte ordering of the data is correct, and
second, make sure that the length of each data type is con-sistent. <br>
</p><p>
Most of the time VTK manages the byte ordering of binary files for you. When you write a binary file on one com-puter <br>
and read it in from another computer, the bytes representing the data will be automatically swapped as necessary. <br>
For example, binary files written on a Sun are stored in big endian order, while those on a PC are stored in little endian <br>
order. As a result, files written on a Sun workstation require byte swapping when read on a PC. (See the class <br>
vtkByteSwap for implementation details.) The VTK data files described here are written in big endian form. <br>
Some file formats, however, do not explicitly define a byte ordering form. You will find that data read or written by <br>
external programs, or the classes vtkVolume16Reader, vtkMCubesReader, and vtkMCubesWriter may have a different <br>
byte order depending on the system of origin. In such cases, VTK allows you to specify the byte order by using the methods <br>
</p><p>
<tt>SetDataByteOrderToBigEndian() <br>
SetDataByteOrderToLittleEndian() <br>
</tt></p><p>
<b>Part 4: </b>Geometry/ topology. <i>Type </i>is one of: <br>
<tt>STRUCTURED_POINTS <br>
STRUCTURED_GRID <br>
UNSTRUCTURED_GRID <br>
POLYDATA <br>
RECTILINEAR_GRID <br>
FIELD <br>
</tt></p><p>
<b>Part 5: </b>Dataset attributes. The number of data <br>
items <i>n </i>of each type must match the number <br>
of points or cells in the dataset. (If <i>type </i>is <br>
<tt>FIELD, </tt>point and cell data should be omitted. <br>
</p><p>
<b>Figure 1 </b>Overview of five parts of VTK data file format. <br>
</p><p>
# vtk DataFile Version 2.0 Really cool data <br>
ASCII | BINARY DATASET <i>type <br>
</i>... POINT_ DATA <i>n <br>
</i>... CELL_ DATA <i>n <br>
</i>... <br>
</p><p>
<b>Part 1: </b>Header <br>
<b>Part 2: </b>Title (256 characters maximum, termi-nated <br>
with newline <tt>\n </tt>character) <br>
</p><p>
<b>Part 3: </b>Data type, either ASCII or BINARY <br>
</p><p>
<i>(1) <br>
(2) <br>
(3) <br>
</i></p><p>
<i>(4) <br>
</i></p><p>
<i>(5) </i>
<br>
Simple Legacy Formats 3 <br>
Another problem with binary files is that systems may use a different number of bytes to represent an integer or other <br>
native type. For example, some 64-bit systems will represent an integer with 8-bytes, while others represent an integer <br>
with 4-bytes. Currently, the <i>Visualization Toolkit </i>cannot handle transporting binary files across systems with incompatible <br>
data length. In this case, use ASCII file formats instead. <br>
</p><p>
<b>Dataset Format. </b>The <i>Visualization Toolkit </i>supports five different dataset formats: structured points, structured grid, rectilinear <br>
grid, unstructured grid, and polygonal data. Data with implicit topology (structured data such as vtkImageData and <br>
vtkStructuredGrid) are ordered with <i>x </i>increasing fastest, then <i>y, </i>thenz. These formats are as follows. <br>
</p><p>
<b>° </b>Structured Points <br>
The file format supports 1D, 2D, and 3D structured point datasets. The dimensions <i>n x ,n y ,n z </i>must be greater than or <br>
equal to 1. The data spacing <i>s x ,s y ,s z </i>must be greater than 0. (Note: in the version 1.0 data file, spacing was referred <br>
to as "aspect ratio". <tt>ASPECT_ RATIO </tt>can still be used in version 2. 0 data files, but is discouraged.) <br>
</p><p>
<tt>DATASET STRUCTURED_ POINTS <br>
DIMENSIONS </tt><i>n x n y n z <br>
</i><tt>ORIGIN </tt><i>x y z <br>
</i><tt>SPACING </tt><i>s x s y s z <br>
</i></p><p>
<b>° </b>Structured Grid <br>
The file format supports 1D, 2D, and 3D structured grid datasets. The dimensions <i>n x ,n y ,n z </i>must be greater than or <br>
equal to 1. The point coordinates are defined by the data in the <tt>POINTS </tt>section. This consists of <i>x-y-z </i>data values for <br>
each point. <br>
</p><p>
<tt>DATASET STRUCTURED_ GRID <br>
DIMENSIONS </tt><i>n x n y n z <br>
</i><tt>POINTS </tt><i>n dataType <br>
p 0x p 0y p 0z <br>
p 1x p 1y p 1z <br>
</i></p><p>
<i>... <br>
p (n-1) x p (n-1) y p (n-1) z <br>
</i></p><p>
<b>° </b>Rectilinear Grid <br>
A rectilinear grid defines a dataset with regular topology, and semi-regular geometry aligned along the <i>x-y-z </i>coordi-nate <br>
axes. The geometry is defined by three lists of monotonically increasing coordinate values, one list for each of <br>
the <i>x-y-z </i>coordinate axes. The topology is defined by specifying the grid dimensions, which must be greater than or <br>
equal to 1. <br>
</p><p>
<tt>DATASET RECTILINEAR_ GRID <br>
DIMENSIONS </tt><i>n x n y n z <br>
</i><tt>X_ COORDINATES </tt><i>n x dataType <br>
x 0 x 1 ... x (nx-1) <br>
</i><tt>Y_ COORDINATES </tt><i>n y dataType <br>
y 0 y 1 ... y (ny-1) <br>
</i><tt>Z_ COORDINATES </tt><i>n z dataType <br>
z 0 z 1 ... z (nz-1) <br>
</i></p><p>
<b>° </b>Polygonal Data <br>
The polygonal dataset consists of arbitrary combinations of surface graphics primitives vertices (and polyvertices), <br>
lines (and polylines), polygons (of various types), and triangle strips. Polygonal data is defined by the <tt>POINTS <br>
VERTICES, LINES, POLYGONS, </tt>orTRIANGLE_ <tt>STRIPS </tt>sections. The <tt>POINTS </tt>definition is the same as we saw for <br>
structured grid datasets. The <tt>VERTICES, LINES, POLYGONS, </tt>orTRIANGLE_ <tt>STRIPS </tt>keywords define the polygonal <br>
dataset topology. Each of these keywords requires two parameters: the number of cells <i>n </i>and the size of the cell list <br>
<i>size. </i>The cell list size is the total number of integer values required to represent the list (i. e., sum of <i>numPoints </i>and 
<br>
4 VTK 4. 2 File Formats <br>
connectivity indices over each cell). None of the keywords <tt>VERTICES, LINES, POLYGONS, </tt>orTRIANGLE_ <tt>STRIPS <br>
</tt>is required. <br>
</p><p>
<tt>DATASET POLYDATA <br>
POINTS </tt><i>n dataType <br>
p 0x p 0y p 0z <br>
p 1x p 1y p 1z <br>
</i></p><p>
<i>... <br>
p (n-1) x p (n-1) y p (n-1) z <br>
</i></p><p>
<tt>VERTICES </tt><i>n size <br>
numPoints 0 </i>, <i>i 0 ,j 0 ,k 0 , ... <br>
numPoints 1 </i>, <i>i 1 ,j 1 ,k 1 , ... <br>
</i>... <br>
<i>numPoints n-1 </i>, <i>i n-1 ,j n-1 ,k n-1 , ... <br>
</i></p><p>
<tt>LINES </tt><i>n size <br>
numPoints 0 </i>, <i>i 0 ,j 0 ,k 0 , ... <br>
numPoints 1 </i>, <i>i 1 ,j 1 ,k 1 , ... <br>
</i>... <br>
<i>numPoints n-1 </i>, <i>i n-1 ,j n-1 ,k n-1 , ... <br>
</i></p><p>
<tt>POLYGONS </tt><i>n size <br>
numPoints 0 </i>, <i>i 0 ,j 0 ,k 0 , ... <br>
numPoints 1 </i>, <i>i 1 ,j 1 ,k 1 , ... <br>
</i>... <br>
<i>numPoints n-1 </i>, <i>i n-1 ,j n-1 ,k n-1 , ... <br>
</i></p><p>
<tt>TRIANGLE_ STRIPS </tt><i>n size <br>
numPoints 0 </i>, <i>i 0 ,j 0 ,k 0 , ... <br>
numPoints 1 </i>, <i>i 1 ,j 1 ,k 1 , ... <br>
</i>... <br>
<i>numPoints n-1 </i>, <i>i n-1 ,j n-1 ,k n-1 , ... <br>
</i></p><p>
<b>° </b>Unstructured Grid <br>
The unstructured grid dataset consists of arbitrary combinations of any possible cell type. Unstructured grids are <br>
defined by points, cells, and cell types. The <tt>CELLS </tt>keyword requires two parameters: the number of cells <i>n </i>and the <br>
size of the cell list <i>size. </i>The cell list size is the total number of integer values required to represent the list (i. e., sum <br>
of <i>numPoints </i>and connectivity indices over each cell). The <tt>CELL_ TYPES </tt>keyword requires a single parameter: the <br>
number of cells <i>n. </i>This value should match the value specified by the <tt>CELLS </tt>keyword. The cell types data is a single <br>
integer value per cell that specified cell type (see <tt>vtkCell. h </tt>or <b>Figure 2). <br>
</b></p><p>
<tt>DATASET UNSTRUCTURED_ GRID <br>
POINTS </tt><i>n dataType <br>
p 0x p 0y p 0z <br>
p 1x p 1y p 1z <br>
</i></p><p>
<i>... <br>
p (n-1) x p (n-1) y p (n-1) z <br>
</i></p><p>
<tt>CELLS </tt><i>n size <br>
numPoints 0 ,i, j, k, l,... <br>
numPoints 1 ,i, j, k, l,... <br>
numPoints 2 ,i, j, k, l,... <br>
</i>... <br>
<i>numPoints n-1 ,i, j, k, l,... </i>
<br>
Simple Legacy Formats 5 <br>
<tt>CELL_ TYPES </tt><i>n <br>
type 0 <br>
type 1 <br>
type 2 <br>
... <br>
type n-1 <br>
</i></p><p>
<b>° </b>Field <br>
Field data is a general format without topological and geometric structure, and without a particular dimensionality. <br>
Typically field data is associated with the points or cells of a dataset. However, if the <tt>FIELD </tt><i>type </i>is specified as the <br>
dataset type (see <b>Figure 1), </b>then a general VTK data object is defined. Use the format described in the next section <br>
to define a field. Also see "Working With Field Data" on page 158 and the fourth example in this chapter "Exam-ples" <br>
on page 7. <br>
</p><p>
<b>Dataset Attribute Format. </b>The <i>Visualization Toolkit </i>supports the following dataset attributes: scalars (one to four com-ponents), <br>
vectors, normals, texture coordinates (1D, 2D, and 3D), tensors, and field data. In addition, a lookup table <br>
using the RGBA color specification, associated with the scalar data, can be defined as well. Dataset attributes are sup-ported <br>
for both points and cells. <br>
Each type of attribute data has a <i>dataName </i>associated with it. This is a character string (without embedded <br>
whitespace) used to identify a particular data. The <i>dataName </i>is used by the VTK readers to extract data. As a result, more <br>
than one attribute data of the same type can be included in a file. For example, two different scalar fields defined on the <br>
dataset points, pressure and temperature, can be contained in the same file. (If the appropriate <i>dataName </i>is not specified in <br>
the VTK reader, then the first data of that type is extracted from the file.) <br>
</p><p>
<b>° </b>Scalars <br>
Scalar definition includes specification of a lookup table. The definition of a lookup table is optional. If not speci-fied, <br>
the default VTK table will be used (and <i>tableName </i>should be "default"). Also note that the <i>numComp </i>vari-able <br>
is optional&#8212; by default the number of components is equal to one. (The parameter <i>numComp </i>must range <br>
between (1,4) inclusive; in versions of VTK prior to vtk2.3 this parameter was not supported.) <br>
</p><p>
<tt>SCALARS </tt><i>dataName dataType numComp <br>
</i><tt>LOOKUP_ TABLE </tt><i>tableName <br>
s 0 <br>
s 1 <br>
... <br>
s n-1 <br>
</i></p><p>
The definition of color scalars (i. e., <tt>unsigned char </tt>values directly mapped to color) varies depending upon the <br>
number of values (nValues) per scalar. If the file format is <tt>ASCII, </tt>the color scalars are defined using <i>nValues </i><tt>float <br>
</tt>values between (0,1). If the file format is <tt>BINARY, </tt>the stream of data consists of <i>nValues </i><tt>unsigned char </tt>values per <br>
scalar value. <br>
</p><p>
<tt>COLOR_ SCALARS </tt><i>dataName nValues <br>
c 00 c 01 ... c 0( nValues-1) <br>
c 10 c 11 ... c 1( nValues-1) <br>
</i>... <br>
<i>c (n-1) 0 c (n-1) 1 ... c (n-1)( nValues-1) <br>
</i></p><p>
<b>° </b>Lookup Table <br>
The <i>tableName </i>field is a character string (without imbedded white space) used to identify the lookup table. This <br>
label is used by the VTK reader to extract a specific table. <br>
</p><p>
Each entry in the lookup table is a <tt>rgba[ 4] </tt>(red-<i>green-blue-alpha) </i>array( <i>alpha </i>is opacity where <i>alpha= 0 </i>is trans-parent). <br>
If the file format is <tt>ASCII, </tt>the lookup table values must be <tt>float </tt>values between (0, 1). If the file format is <br>
</p><p>
3 3 × 
<br>
6 VTK 4. 2 File Formats <br>
<tt>BINARY, </tt>the stream of data must be four unsigned char values per table entry. <br>
<tt>LOOKUP_ TABLE </tt><i>tableName size <br>
r 0 g 0 b 0 a 0 <br>
r 1 g 1 b 1 a 1 <br>
</i>... <br>
<i>r size-1 g size-1 b size-1 a size-1 <br>
</i></p><p>
<b>° </b>Vectors <br>
<tt>VECTORS </tt><i>dataName dataType <br>
v 0x v 0y v 0z <br>
v 1x v 1y v 1z <br>
</i></p><p>
<i>... <br>
v (n-1) x v (n-1) y v (n-1) z <br>
</i></p><p>
<b>° </b>Normals <br>
Normals are assumed normalized . <br>
</p><p>
<tt>NORMALS </tt><i>dataName dataType <br>
n 0x n 0y n 0z <br>
n 1x n 1y n 1z <br>
</i></p><p>
<i>... <br>
n (n-1) x n (n-1) y n (n-1) z <br>
</i></p><p>
<b>° </b>Texture Coordinates <br>
Texture coordinates of 1, 2, and 3 dimensions are supported. <br>
</p><p>
<tt>TEXTURE_ COORDINATES </tt><i>dataName dim dataType <br>
t 00 t 01 ... t 0( dim-1) <br>
t 10 t 11 ... t 1( dim-1) <br>
</i></p><p>
<i>... <br>
t (n-1) 0 t (n-1) 1 ... t (n-1)( dim-1) <br>
</i></p><p>
<b>° </b>Tensors <br>
Currently only real-valued, symmetric tensors are supported. <br>
</p><p>
<tt>TENSORS </tt><i>dataName dataType <br>
t 0 00 t 0 01 t 0 02 <br>
t 0 10 t 0 11 t 0 12 <br>
t 0 20 t 0 21 t 0 22 <br>
</i></p><p>
<i>t 1 00 t 1 01 t 1 02 <br>
t 1 10 t 1 11 t 1 12 <br>
t 1 20 t 1 21 t 1 22 <br>
</i></p><p>
<i>... <br>
t n-1 00 t n-1 01 t n-1 02 <br>
</i></p><p>
<i>t n-1 10 t n-1 11 t n-1 12 <br>
t n-1 20 t n-1 21 t n-1 22 <br>
</i></p><p>
<b>° </b>Field Data <br>
Field data is essentially an array of data arrays. Defining field data means giving a name to the field and specifying <br>
the number of arrays it contains. Then, for each array, the name of the array <i>arrayName( i), </i>the number of compo-nents <br>
of the array, <i>numComponents, </i>the number of tuples in the array, <i>numTuples, </i>and the data type, <i>dataType, </i>are <br>
</p><p>
<i>n </i>1 = <br>
3 3 × 
<br>
Simple Legacy Formats 7 <br>
defined. <br>
<tt>FIELD </tt><i>dataName numArrays <br>
arrayName0 numComponents numTuples dataType <br>
f 00 f 01 ... f 0( numComponents-1) <br>
f 10 f 11 ... f 1( numComponents-1) <br>
</i><tt>... <br>
</tt><i>f (numTuples-1) 0 f (numTuples-1) 1 ... f (numTuples-1)( numComponents-1) <br>
</i></p><p>
<i>arrayName1 numComponents numTuples dataType <br>
f 00 f 01 ... f 0( numComponents-1) <br>
f 10 f 11 ... f 1( numComponents-1) <br>
</i><tt>... <br>
</tt><i>f (numTuples-1) 0 f (numTuples-1) 1 ... f (numTuples-1)( numComponents-1) <br>
</i></p><p>
<tt>... <br>
</tt><i>arrayName( numArrays-1) numComponents numTuples dataType <br>
f 00 f 01 ... f 0( numComponents-1) <br>
f 10 f 11 ... f 1( numComponents-1) <br>
</i><tt>... <br>
</tt><i>f (numTuples-1) 0 f (numTuples-1) 1 ... f (numTuples-1)( numComponents-1) <br>
</i></p><p>
<b>Examples. </b>The first example is a cube represented by six polygonal faces. We define a single-component scalar, normals, <br>
and field data on the six faces. There are scalar data associated with the eight vertices. A lookup table of eight colors, <br>
associated with the point scalars, is also defined. <br>
</p><p>
<tt># vtk DataFile Version 2.0 <br>
Cube example <br>
ASCII <br>
DATASET POLYDATA <br>
POINTS 8 float <br>
0.0 0.0 0.0 <br>
1.0 0.0 0.0 <br>
1.0 1.0 0.0 <br>
0.0 1.0 0.0 <br>
0.0 0.0 1.0 <br>
1.0 0.0 1.0 <br>
1.0 1.0 1.0 <br>
0.0 1.0 1.0 <br>
POLYGONS 6 30 <br>
40 1 2 3 <br>
44 5 6 7 <br>
40 1 5 4 <br>
42 3 7 6 <br>
40 4 7 3 <br>
41 2 6 5 <br>
</tt></p><p>
<tt>CELL_ DATA 6 <br>
SCALARS cell_ scalars int 1 <br>
LOOKUP_ TABLE default <br>
0 <br>
1 <br>
2 <br>
3 <br>
4 <br>
5 <br>
NORMALS cell_ normals float </tt>
<br>
8 VTK 4. 2 File Formats <br>
<tt>0 0-1 <br>
0 01 <br>
0 -10 <br>
0 10 <br>
-1 0 0 <br>
1 00 <br>
FIELD FieldData 2 <br>
cellIds 1 6 int <br>
01 2 3 4 5 <br>
faceAttributes 2 6 float <br>
0.0 1.0 1.0 2.0 2.0 3.0 3.0 4.0 4.0 5.0 5.0 6.0 <br>
</tt></p><p>
<tt>POINT_ DATA 8 <br>
SCALARS sample_ scalars float 1 <br>
LOOKUP_ TABLE my_ table <br>
0.0 <br>
1.0 <br>
2.0 <br>
3.0 <br>
4.0 <br>
5.0 <br>
6.0 <br>
7.0 <br>
LOOKUP_ TABLE my_ table 8 <br>
0.0 0.0 0.0 1.0 <br>
1.0 0.0 0.0 1.0 <br>
0.0 1.0 0.0 1.0 <br>
1.0 1.0 0.0 1.0 <br>
0.0 0.0 1.0 1.0 <br>
1.0 0.0 1.0 1.0 <br>
0.0 1.0 1.0 1.0 <br>
1.0 1.0 1.0 1.0 <br>
</tt></p><p>
The next example is a volume of dimension . Since no lookup table is defined, either the user must create one in <br>
VTK, or the default lookup table will be used. <br>
</p><p>
<tt># vtk DataFile Version 2.0 <br>
Volume example <br>
ASCII <br>
DATASET STRUCTURED_ POINTS <br>
DIMENSIONS 3 4 6 <br>
ASPECT_ RATIO 1 1 1 <br>
ORIGIN 0 0 0 <br>
POINT_ DATA 72 <br>
SCALARS volume_ scalars char 1 <br>
LOOKUP_ TABLE default <br>
00 0 0 0 0 0 0 00 0 0 <br>
0 5 10 15 20 25 25 20 15 10 5 0 <br>
010 20 30 40 50 50 40 30 20 10 0 <br>
010 20 30 40 50 50 40 30 20 10 0 <br>
0 5 10 15 20 25 25 20 15 10 5 0 <br>
00 0 0 0 0 0 0 00 0 0 <br>
</tt></p><p>
The third example is an unstructured grid containing twelve of the nineteen VTK cell types (see <b>Figure 2 </b>and <b>Figure 3). <br>
</b>The file contains scalar and vector data. <br>
</p><p>
<tt># vtk DataFile Version 2.0 <br>
Unstructured Grid Example <br>
ASCII <br>
</tt></p><p>
3 4 5 × × 
<br>
Simple Legacy Formats 9 <br>
<tt>DATASET UNSTRUCTURED_ GRID <br>
POINTS 27 float <br>
000 1 0 0 200 0 1 0 1 10 2 1 0 <br>
001 1 0 1 201 0 1 1 1 11 2 1 1 <br>
012 1 1 2 212 0 1 3 1 13 2 1 3 <br>
014 1 1 4 214 0 1 5 1 15 2 1 5 <br>
0 16 116 2 16 <br>
</tt></p><p>
<tt>CELLS 11 60 <br>
</tt></p><p>
<tt>VTK_ VERTEX (= 1) VTK_ LINE (= 3) VTK_ POLY_ VERTEX (= 2) <br>
VTK_ POLY_ LINE (= 4) VTK_ TRIANGLE_ STRIP (= 6) VTK_ TRIANGLE(= 5) <br>
</tt></p><p>
<tt>VTK_ QUAD (= 9) VTK_ POLYGON (= 7) VTK_ PIXEL (= 8) <br>
</tt></p><p>
<tt>VTK_ TETRA (= 10) VTK_ VOXEL (= 11) VTK_ HEXAHEDRON (= 12) <br>
</tt><i>0 1 <br>
</i></p><p>
<i>2 3 <br>
</i></p><p>
<i>4 5 <br>
7 6 <br>
</i></p><p>
<i>0 1 <br>
2 <br>
</i></p><p>
<i>4 5 <br>
6 7 <br>
</i></p><p>
<i>3 <br>
</i></p><p>
<i>3 <br>
</i></p><p>
<i>0 1 <br>
2 <br>
</i></p><p>
<i>2 <br>
3 <br>
1 <br>
0 0 1 <br>
</i></p><p>
<i>3 2 <br>
0 1 <br>
</i></p><p>
<i>n-2 <br>
n-1 <br>
</i></p><p>
<i>0 <br>
1 <br>
n-1 <br>
n <br>
</i></p><p>
<i>0 <br>
</i></p><p>
<i>2 <br>
1 <br>
0 <br>
</i></p><p>
<i>1 3 <br>
</i></p><p>
<i>2 n <br>
</i></p><p>
<i>n+ 1 <br>
</i></p><p>
<i>x <br>
y z <br>
</i></p><p>
<i>x i <br>
x j <br>
</i></p><p>
<b>Figure 2 </b>Linear cell types found in VTK. Use the include file CellType. h to manipulate cell types. <br>
<tt>VTK_ WEDGE (= 13) <br>
</tt></p><p>
<i>2 <br>
0 1 <br>
</i></p><p>
<i>5 <br>
3 4 <br>
</i></p><p>
<tt>VTK_ PYRAMID (= 14) <br>
</tt></p><p>
<i>3 <br>
0 1 <br>
</i></p><p>
<i>2 <br>
4 </i>
<br>
10 VTK 4. 2 File Formats <br>
<tt>80 1 4 3 6 7 10 9 <br>
81 2 5 4 7 8 11 10 <br>
4610 9 12 <br>
4 5 11 10 14 <br>
615 16 17 14 13 12 <br>
618 15 19 16 20 17 <br>
422 23 20 19 <br>
321 22 18 <br>
322 19 18 <br>
2 2625 <br>
1 24 <br>
</tt></p><p>
<tt>CELL_ TYPES 11 <br>
12 <br>
12 <br>
10 <br>
10 <br>
7 <br>
6 <br>
9 <br>
5 <br>
5 <br>
3 <br>
1 <br>
</tt></p><p>
<tt>POINT_ DATA 27 <br>
SCALARS scalars float 1 <br>
LOOKUP_ TABLE default <br>
0.0 1.0 2.0 3.0 4.0 5.0 <br>
6.0 7.0 8.0 9.0 10.0 11.0 <br>
12. 0 13.0 14.0 15.0 16.0 17.0 <br>
18. 0 19.0 20.0 21.0 22.0 23.0 <br>
24. 0 25.0 26.0 <br>
VECTORS vectors float <br>
100 1 1 0 020 1 0 0 1 10 0 2 0 <br>
</tt></p><p>
<b>Figure 3 </b>Non-linear cell types found in VTK. <br>
<i>5 <br>
3 <br>
7 <br>
4 <br>
</i></p><p>
<i>5 <br>
6 <br>
</i></p><p>
<i>17 <br>
15 12 <br>
</i></p><p>
<i>11 <br>
8 <br>
9 <br>
</i></p><p>
<i>13 <br>
18 <br>
3 <br>
5 <br>
</i></p><p>
<i>7 6 <br>
</i></p><p>
<i>2 <br>
1 0 <br>
</i></p><p>
<i>4 <br>
</i></p><p>
<i>4 <br>
6 7 <br>
</i></p><p>
<i>9 <br>
</i></p><p>
<i>5 <br>
</i></p><p>
<i>3 <br>
</i></p><p>
<i>0 <br>
2 1 <br>
</i></p><p>
<i>0 <br>
1 <br>
</i></p><p>
<i>2 <br>
0 <br>
</i></p><p>
<i>2 <br>
1 <br>
</i></p><p>
<i>2 <br>
3 <br>
1 <br>
0 <br>
</i></p><p>
<i>1 <br>
8 <br>
</i></p><p>
<i>14 <br>
19 <br>
16 10 <br>
</i></p><p>
<i>0 <br>
4 <br>
</i></p><p>
<tt>VTK_ QUADRATIC_ TETRA <br>
(= 24) <br>
VTK_ QUADRATIC_ HEXAHEDRON <br>
(= 25) <br>
</tt></p><p>
<tt>VTK_ QUADRATIC_ EDGE <br>
(= 21) <br>
VTK_ QUADRATIC_ QUAD <br>
(= 23) <br>
</tt></p><p>
<tt>VTK_ QUADRATIC_ TRIANGLE <br>
(= 22) </tt>
<tt>100 1 1 0 020 1 0 0 1 10 0 2 0 <br>
001 0 0 1 001 0 0 1 0 01 0 0 1 <br>
001 0 0 1 001 0 0 1 0 01 0 0 1 <br>
0 01 001 0 01 <br>
</tt></p><p>
The fourth and final example is data represented as a field. You may also wish to see "Working With Field Data" on <br>
page 158 to see how to manipulate this data. (The data file shown below can be found in its entirety in <br>
<tt>$VTK_ DATA_ ROOT/ Data/ financial. vtk.) <br>
</tt></p><p>
<tt># vtk DataFile Version 2.0 <br>
Financial data in vtk field format <br>
ASCII <br>
FIELD financialData 6 <br>
TIME_ LATE 1 3188 float <br>
29.14 0.00 0.00 11.71 0.00 0.00 0.00 0.00 <br>
...( more stuff &#8212; 3188 total values)... <br>
</tt></p><p>
<tt>MONTHLY_ PAYMENT 1 3188 float <br>
7.26 5.27 8.01 16.84 8.21 15.75 10.62 15.47 <br>
...( more stuff)... <br>
</tt></p><p>
<tt>UNPAID_ PRINCIPLE 1 3188 float <br>
430.70 380.88 516.22 1351.23 629.66 1181.97 888.91 1437.83 <br>
...( more stuff)... <br>
</tt></p><p>
<tt>LOAN_ AMOUNT 1 3188 float <br>
441.50 391.00 530.00 1400.00 650.00 1224.00 920.00 1496.00 <br>
...( more stuff)... <br>
</tt></p><p>
<tt>INTEREST_ RATE 1 3188 float <br>
13.875 13.875 13. 750 11.250 11.875 12.875 10.625 10.500 <br>
...( more stuff)... <br>
</tt></p><p>
<tt>MONTHLY_ INCOME 1 3188 unsigned_ short <br>
39 51 51 38 35 49 45 56 <br>
...( more stuff)... <br>
</tt></p><p>
In this example, a field is represented using six arrays. Each array has a single component and 3, 188 tuples. Five of the six <br>
arrays are of type <tt>float, </tt>while the last array is of type <tt>unsigned_ short. <br>
</tt>Additional examples are available in the data directory. <br>
</p><p>
</dir>
<b>XML File Formats <br>
<dir>
</b>VTK provides another set of data formats using XML syntax. While these formats are much more complicated than the <br>
original VTK format described previously (see "Simple Legacy Formats" on page 1), they support many more features. <br>
The major motivation for their development was to facilitate data streaming and parallel I/ O. Some features of the format <br>
include support for compression, portable binary encoding, random access, big endian and little endian byte order, multi-ple <br>
file representation of piece data, and new file extensions for different VTK dataset types. XML provides many features <br>
as well, especially the ability to extend a file format with application specific tags. <br>
There are two types of VTK XML data files: parallel and serial as described in the following. <br>
</p><p>
<b>° Serial. </b>File types designed for reading and writing by applications of only a single process. All of the data are contained <br>
within a single file. <br>
</p><p>
<b>° Parallel. </b>File types designed for reading and writing by applications with multiple processes executing in parallel. <br>
The dataset is broken into pieces. Each process is assigned a piece or set of pieces to read or write. An individual <br>
piece is stored in a corresponding serial file type. The parallel file type does not actually contain any data, but <br>
instead describes structural information and then references other serial files containing the data for each piece. <br>
</p><p>
In the XML format, VTK datasets are classified into one of two categories. 
<br>
12 VTK 4. 2 File Formats <br>
<b>°Structured. </b>The dataset is a topologically regular array of cells such as pixels and voxels (e. g., image data) or quad-rilaterals <br>
and hexahedra (e. g., structured grid) (see "The Visualization Model" on page 19 for more information). <br>
Rectangular subsets of the data are described through extents. The structured dataset types are vtkImageData, <br>
vtkRectilinearGrid, and vtkStructuredGrid. <br>
</p><p>
<b>° Unstructured. </b>The dataset forms a topologically irregular set of points and cells. Subsets of the data are described <br>
using pieces. The unstructured dataset types are vtkPolyData and vtkUnstructuredGrid (see "The Visualization <br>
Model" on page 19 for more information). <br>
</p><p>
By convention, each data type and file type is paired with a particular file extension. The types and corresponding exten-sions <br>
are <br>
</p><p>
<b>° </b>ImageData (. <tt>vti) </tt>&#8212;Serial vtkImageData (structured). <br>
<b>° </b>PolyData (. <tt>vtp) </tt>&#8212; Serial vtkPolyData (unstructured). <br>
<b>° </b>RectilinearGrid (. <tt>vtr) </tt>&#8212; Serial vtkRectilinearGrid (structured). <br>
<b>° </b>StructuredGrid (. <tt>vts) </tt>&#8212;Serial vtkStructuredGrid (structured). <br>
<b>° </b>UnstructuredGrid (. <tt>vtu) </tt>&#8212;Serial vtkUnstructuredGrid (unstructured). <br>
<b>° </b>PImageData (. <tt>pvti) </tt>&#8212;Parallel vtkImageData (structured). <br>
<b>° </b>PPolyData (. <tt>pvtp) </tt>&#8212; Parallel vtkPolyData (unstructured). <br>
<b>° </b>PRectilinearGrid (. <tt>pvtr) </tt>&#8212; Parallel vtkRectilinearGrid (structured). <br>
<b>° </b>PStructuredGrid (. <tt>pvts) </tt>&#8212; Parallel vtkStructuredGrid (structured). <br>
<b>° </b>PUnstructuredGrid (. <tt>pvtu) </tt>&#8212;Parallel vtkUnstructuredGrid (unstructured). <br>
</p><p>
All of the VTK XML file types are valid XML documents. * The document-level element is <tt>VTKFile: <br>
</tt></p><p>
<tt>&lt;VTKFile type=" ImageData" version=" 0.1" byte_ order=" LittleEndian"&gt; <br>
... <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
The attributes of the element are: <br>
<tt>type </tt>&#8212; The type of the file (the bulleted items in the previous list).. <br>
<tt>version </tt>&#8212;File version number in "major. minor" format. <br>
<tt>byte_ order </tt>&#8212; Machine byte order in which data are stored. This is either "BigEndian" or "LittleEndian". <br>
<tt>compressor </tt>&#8212; Some data in the file may be compressed. This specifies the subclass of vtkDataCompressor that <br>
was used to compress the data. <br>
</p><p>
Nested inside the <tt>VTKFile </tt>element is an element whose name corresponds to the type of the data format (i. e., the <tt>type <br>
</tt>attribute). This element describes the topology the dataset, and is different for the serial and parallel formats, which are <br>
described as follows. <br>
</p><p>
<b>Serial XML File Formats. </b>The <tt>VTKFile </tt>element contains one element whose name corresponds to the type of dataset <br>
the file describes. We refer to this as the dataset element, which is one of <tt>ImageData, RectilinearGrid, <br>
StructuredGrid, PolyData, </tt>orUnstructuredGrid. The dataset element contains one or more <tt>Piece </tt>elements, each <br>
describing a portion of the dataset. Together, the dataset element and <tt>Piece </tt>elements specify the entire dataset. <br>
Each piece of a dataset must specify the geometry (points and cells) of that piece along with the data associated with <br>
each point or cell. Geometry is specified differently for each dataset type, but every piece of every dataset contains <br>
<tt>PointData </tt>and <tt>CellData </tt>elements specifying the data for each point and cell in the piece. <br>
The general structure for each serial dataset format is as follows: <br>
</p><p>
<b>° ImageData </b>&#8212; Each <tt>ImageData </tt>piece specifies its extent within the dataset's whole extent. The points and cells <br>
</p><p>
* There is one case in which the file is not a valid XML document. When the AppendedData section is not encoded as base64, <br>
raw binary data is present that may violate the XML specification. This is not default behavior, and must be explicitly enabled <br>
by the user. 
<br>
XML File Formats 13 <br>
are described implicitly by the extent, origin, and spacing. Note that the origin and spacing are constant across all <br>
pieces, so they are specified as attributes of the <tt>ImageData </tt>XML element as follows. <br>
</p><p>
<tt>&lt;VTKFile type=" ImageData" ...&gt; <br>
&lt;ImageData WholeExtent=" x1 x2 y1 y2 z1 z2" <br>
Origin=" x0 y0 z0" Spacing=" dx dy dz"&gt; <br>
&lt;Piece Extent=" x1 x2 y1 y2 z1 z2"&gt; <br>
&lt;PointData&gt;...&lt;/ PointData&gt; <br>
&lt;CellData&gt;...&lt;/ CellData&gt; <br>
&lt;/ Piece&gt; <br>
&lt;/ ImageData&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>° RectilinearGrid </b>&#8212; Each <tt>RectilinearGrid </tt>piece specifies its extent within the dataset's whole extent. The <br>
points are described by the <tt>Coordinates </tt>element. The cells are described implicitly by the extent. <br>
</p><p>
<tt>&lt;VTKFile type=" RectilinearGrid" ...&gt; <br>
&lt;RectilinearGrid WholeExtent=" x1 x2 y1 y2 z1 z2"&gt; <br>
&lt;Piece Extent=" x1 x2 y1 y2 z1 z2"&gt; <br>
&lt;PointData&gt;...&lt;/ PointData&gt; <br>
&lt;CellData&gt;...&lt;/ CellData&gt; <br>
&lt;Coordinates&gt;...&lt;/ Coordinates&gt; <br>
&lt;/ Piece&gt; <br>
&lt;/ RectilinearGrid&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>° StructuredGrid </b>&#8212; Each <tt>StructuredGrid </tt>piece specifies its extent within the dataset's whole extent. The points <br>
are described explicitly by the <tt>Points </tt>element. The cells are described implicitly by the extent. <br>
</p><p>
<tt>&lt;VTKFile type=" StructuredGrid" ...&gt; <br>
&lt;StructuredGrid WholeExtent=" x1 x2 y1 y2 z1 z2"&gt; <br>
&lt;Piece Extent=" x1 x2 y1 y2 z1 z2"&gt; <br>
&lt;PointData&gt;...&lt;/ PointData&gt; <br>
&lt;CellData&gt;...&lt;/ CellData&gt; <br>
&lt;Points&gt;...&lt;/ Points&gt; <br>
&lt;/ Piece&gt; <br>
&lt;/ StructuredGrid&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>° PolyData </b>&#8212; Each <tt>PolyData </tt>piece specifies a set of points and cells independently from the other pieces. The <br>
points are described explicitly by the <tt>Points </tt>element. The cells are described explicitly by the <tt>Verts, Lines, <br>
Strips, </tt>andPolys elements. <br>
</p><p>
<tt>&lt;VTKFile type=" PolyData" ...&gt; <br>
&lt;PolyData&gt; <br>
&lt;Piece NumberOfPoints="#" NumberOfVerts="#" NumberOfLines="#" <br>
NumberOfStrips="#" NumberOfPolys="#"&gt; <br>
&lt;PointData&gt;...&lt;/ PointData&gt; <br>
&lt;CellData&gt;...&lt;/ CellData&gt; <br>
&lt;Points&gt;...&lt;/ Points&gt; <br>
&lt;Verts&gt;...&lt;/ Verts&gt; <br>
&lt;Lines&gt;...&lt;/ Lines&gt; <br>
&lt;Strips&gt;...&lt;/ Strips&gt; <br>
&lt;Polys&gt;...&lt;/ Polys&gt; <br>
&lt;/ Piece&gt; </tt>
<br>
14 VTK 4. 2 File Formats <br>
<tt>&lt;/ PolyData&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>° UnstructuredGrid </b>&#8212; Each <tt>UnstructuredGrid </tt>piece specifies a set of points and cells independently from the <br>
other pieces. The points are described explicitly by the <tt>Points </tt>element. The cells are described explicitly by the <br>
<tt>Cells </tt>element. <br>
</p><p>
<tt>&lt;VTKFile type=" UnstructuredGrid" ...&gt; <br>
&lt;UnstructuredGrid&gt; <br>
&lt;Piece NumberOfPoints="#" NumberOfCells="#"&gt; <br>
&lt;PointData&gt;...&lt;/ PointData&gt; <br>
&lt;CellData&gt;...&lt;/ CellData&gt; <br>
&lt;Points&gt;...&lt;/ Points&gt; <br>
&lt;Cells&gt;...&lt;/ Cells&gt; <br>
&lt;/ Piece&gt; <br>
&lt;/ UnstructuredGrid&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
Every dataset describes the data associated with its points and cells with <tt>PointData </tt>and <tt>CellData </tt>XML elements as <br>
follows: <br>
</p><p>
<tt>&lt;PointData Scalars=" Temperature" Vectors=" Velocity"&gt; <br>
&lt;DataArray Name=" Velocity" .../&gt; <br>
&lt;DataArray Name=" Temperature" .../&gt; <br>
&lt;DataArray Name=" Pressure" .../&gt; <br>
&lt;/ PointData&gt; <br>
</tt></p><p>
VTK allows an arbitrary number of data arrays to be associated with the points and cells of a dataset. Each data array is <br>
described by a <tt>DataArray </tt>element which, among other things, gives each array a name. The following attributes of <br>
<tt>PointData </tt>and <tt>CellData </tt>are used to specify the active arrays by name: <br>
</p><p>
<tt>Scalars </tt>&#8212;The name of the active scalars array, if any. <br>
<tt>Vectors </tt>&#8212;The name of the active vectors array, if any. <br>
<tt>Normals </tt>&#8212; The name of the active normals array, if any. <br>
<tt>Tensors </tt>&#8212;The name of the active tensors array, if any. <br>
<tt>TCoords </tt>&#8212; The name of the active texture coordinates array, if any. <br>
Some datasets describe their points and cells using different combinations of the following common elements: <br>
</p><p>
<b>°Points&#8212; </b>ThePoints element explicitly defines coordinates for each point individually. It contains one <br>
<tt>DataArray </tt>element describing an array with three components per value, each specifying the coordinates of one <br>
point. <br>
</p><p>
<tt>&lt;Points&gt; <br>
&lt;DataArray NumberOfComponents=" 3" .../&gt; <br>
&lt;/ Points&gt; <br>
</tt></p><p>
<tt>Coordinates </tt>&#8212;TheCoordinates element defines point coordinates for an extent by specifying the ordinate <br>
along each axis for each integer value in the extent's range. It contains three <tt>DataArray </tt>elements describing the <br>
ordinates along the <i>x-y-z </i>axes, respectively. <br>
</p><p>
<tt>&lt;Coordinates&gt; <br>
&lt;DataArray .../&gt; <br>
&lt;DataArray .../&gt; <br>
&lt;DataArray .../&gt; </tt>
<br>
XML File Formats 15 <br>
<tt>&lt;/ Coordinates&gt; <br>
</tt><b>° Verts, Lines, Strips, </b>andPolys &#8212;TheVerts, <tt>Lines, Strips, </tt>andPolys elements define cells explicitly by <br>
specifying point connectivity. Cell types are implicitly known by the type of element in which they are specified. <br>
Each element contains two <tt>DataArray </tt>elements. The first array specifies the point connectivity. All the cells' point <br>
lists are concatenated together. The second array specifies the offset into the connectivity array for the end of each <br>
cell. <br>
</p><p>
<tt>&lt;Verts&gt; <br>
&lt;DataArray type=" Int32" Name=" connectivity" .../&gt; <br>
&lt;DataArray type=" Int32" Name=" offsets" .../&gt; <br>
&lt;/ Verts&gt; <br>
</tt></p><p>
<b>° Cells </b>&#8212;TheCells element defines cells explicitly by specifying point connectivity and cell types. It contains three <br>
<tt>DataArray </tt>elements. The first array specifies the point connectivity. All the cells' point lists are concatenated <br>
together. The second array specifies the offset into the connectivity array for the end of each cell. The third array <br>
specifies the type of each cell. (Note: the cell types are defined in <b>Figure 2 </b>and <b>Figure 3.) <br>
</b></p><p>
<tt>&lt;Cells&gt; <br>
&lt;DataArray type=" Int32" Name=" connectivity" .../&gt; <br>
&lt;DataArray type=" Int32" Name=" offsets" .../&gt; <br>
&lt;DataArray type=" UInt8" Name=" types" .../&gt; <br>
&lt;/ Cells&gt; <br>
</tt></p><p>
All of the data and geometry specifications use <tt>DataArray </tt>elements to describe their actual content as follows: <br>
<b>° DataArray </b>&#8212;TheDataArray element stores a sequence of values of one type. There may be one or more compo-nents <br>
per value. <br>
</p><p>
<tt>&lt;DataArray type=" Float32" Name=" vectors" NumberOfComponents=" 3" <br>
format=" appended" offset=" 0"/&gt; <br>
&lt;DataArray type=" Float32" Name=" scalars" format=" binary"&gt; <br>
bAAAAAAAAAAAAIA/ AAAAQAAAQEAAAIBA... &lt;/ DataArray&gt; <br>
&lt;DataArray type=" Int32" Name=" offsets" format=" ascii"&gt; <br>
10 20 30 ... &lt;/ DataArray&gt; <br>
</tt></p><p>
The attributes of the <tt>DataArray </tt>elements are described as follows: <br>
<tt>type </tt>&#8212; The data type of a single component of the array. This is one of <tt>Int8, UInt8, Int16, UInt16, Int32, <br>
UInt32, Int64, UInt64, Float32, Float64. </tt>Note: the 64-bit integer types are only supported if <br>
<tt>VTK_ USE_ 64BIT_ IDS </tt>is on (a CMake variable&#8212; see "CMake" on page 8) or the platform is 64-bit. <br>
</p><p>
<tt>Name </tt>&#8212; The name of the array. This is usually a brief description of the data stored in the array. <br>
<tt>NumberOfComponents </tt>&#8212;The number of components per value in the array. <br>
<tt>format </tt>&#8212; The means by which the data values themselves are stored in the file. This is "ascii", "binary", or <br>
"appended". <br>
</p><p>
<tt>offset </tt>&#8212; If the format attribute is "appended", this specifies the offset from the beginning of the appended data <br>
section to the beginning of this array's data. <br>
</p><p>
The <tt>format </tt>attribute chooses among the three ways in which data values can be stored: <br>
</p><p>
<tt>format=" ascii" </tt>&#8212; The data are listed in ASCII directly inside the <tt>DataArray </tt>element. Whitespace is used for <br>
separation. <br>
</p><p>
<tt>format=" binary" </tt>&#8212; The data are encoded in base64 and listed contiguously inside the <tt>DataArray </tt>element. <br>
Data may also be compressed before encoding in base64. The byte-order of the data matches that specified by 
<br>
16 VTK 4. 2 File Formats <br>
the <tt>byte_ order </tt>attribute of the <tt>VTKFile </tt>element. <br>
<tt>format=" appended" </tt>&#8212; The data are stored in the appended data section. Since many <tt>DataArray </tt>elements may <br>
store their data in this section, the offset attribute is used to specify where each <tt>DataArray's </tt>data begins. <br>
This format is the default used by VTK's writers. <br>
</p><p>
The appended data section is stored in an <tt>AppendedData </tt>element that is nested inside <tt>VTKFile </tt>after the <br>
dataset element: <br>
<tt>&lt;VTKFile ...&gt; <br>
... <br>
&lt;AppendedData encoding=" base64"&gt; <br>
_QMwEAAAAAAAAA... <br>
&lt;/ AppendedData&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
The appended data section begins with the first character after the underscore inside the <tt>AppendedData </tt>ele-ment. <br>
The underscore is not part of the data, but is always present. Data in this section is always in binary <br>
form, but can be compressed and/ or base64 encoded. The byte-order of the data matches that specified by the <br>
<tt>byte_ order </tt>attribute of the <tt>VTKFile </tt>element. Each <tt>DataArray's </tt>data are stored contiguously and <br>
appended immediately after the previous <tt>DataArray's </tt>data without a seperator. The <tt>DataArray's offset <br>
</tt>attribute indicates the file position offset from the first character after the underscore to the beginning its data. <br>
</p><p>
<b>Parallel File Formats. </b>The parallel file formats do not actually store any data in the file. Instead, the data are broken into <br>
pieces, each of which is stored in a serial file of the same dataset type. <br>
The <tt>VTKFile </tt>element contains one element whose name corresponds to the type of dataset the file describes, but <br>
with a "P" prefix. We refer to this as the parallel dataset element, which is one of PImageData, PRectilinearGrid, <br>
PStructuredGrid, PPolyData, or PUnstructuredGrid. <br>
The parallel dataset element and those nested inside specify the types of the data arrays used to store points, point <br>
data, and cell data (the type of arrays used to store cells is fixed by VTK). The element does not actually contain any data, <br>
but instead includes a list of <tt>Piece </tt>elements that specify the source from which to read each piece. Individual pieces are <br>
stored in the corresponding serial file format. The parallel file needs to specify the type and structural information so that <br>
readers can update pipeline information without actually reading the pieces' files. <br>
The general structure for each parallel dataset format is as follows: <br>
</p><p>
<b>° PImageData </b>&#8212;ThePImageData element specifies the whole extent of the dataset and the number of ghost-levels <br>
by which the extents in the individual pieces overlap. The <tt>Origin </tt>and <tt>Spacing </tt>attributes implicitly specify the <br>
point locations. Each <tt>Piece </tt>element describes the extent of one piece and the file in which it is stored. <br>
</p><p>
<tt>&lt;VTKFile type=" PImageData" ...&gt; <br>
&lt;PImageData WholeExtent=" x1 x2 y1 y2 z1 z2" <br>
GhostLevel="#" Origin=" x0 y0 z0" Spacing=" dx dy dz"&gt; <br>
&lt;PPointData&gt;...&lt;/ PPointData&gt; <br>
&lt;PCellData&gt;...&lt;/ PCellData&gt; <br>
&lt;Piece Extent=" x1 x2 y1 y2 z1 z2" Source=" imageData0. vti"/&gt; <br>
... <br>
&lt;/ PImageData&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>° PRectilinearGrid </b>&#8212;ThePRectilinearGrid element specifies the whole extent of the dataset and the number of <br>
ghost-levels by which the extents in the individual pieces overlap. The <tt>PCoordinates </tt>element describes the type <br>
of arrays used to specify the point ordinates along each axis, but does not actually contain the data. Each <tt>Piece </tt>ele-ment <br>
describes the extent of one piece and the file in which it is stored. <br>
</p><p>
<tt>&lt;VTKFile type=" PRectilinearGrid" ...&gt; <br>
&lt;PRectilinearGrid WholeExtent=" x1 x2 y1 y2 z1 z2" <br>
GhostLevel="#"&gt; </tt>
<br>
XML File Formats 17 <br>
<tt>&lt;PPointData&gt;...&lt;/ PPointData&gt; <br>
&lt;PCellData&gt;...&lt;/ PCellData&gt; <br>
&lt;PCoordinates&gt;...&lt;/ PCoordinates&gt; <br>
&lt;Piece Extent=" x1 x2 y1 y2 z1 z2" <br>
Source=" rectilinearGrid0. vtr"/&gt; <br>
... <br>
&lt;/ PRectilinearGrid&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>° PStructuredGrid </b>&#8212;ThePStructuredGrid element specifies the whole extent of the dataset and the number of <br>
ghost-levels by which the extents in the individual pieces overlap. The <tt>PPoints </tt>element describes the type of array <br>
used to specify the point locations, but does not actually contain the data. Each <tt>Piece </tt>element describes the extent <br>
of one piece and the file in which it is stored. <br>
</p><p>
<tt>&lt;VTKFile type=" PStructuredGrid" ...&gt; <br>
&lt;PStructuredGrid WholeExtent=" x1 x2 y1 y2 z1 z2" <br>
GhostLevel="#"&gt; <br>
&lt;PPointData&gt;...&lt;/ PPointData&gt; <br>
&lt;PCellData&gt;...&lt;/ PCellData&gt; <br>
&lt;PPoints&gt;...&lt;/ PPoints&gt; <br>
&lt;Piece Extent=" x1 x2 y1 y2 z1 z2" <br>
Source=" structuredGrid0. vts"/&gt; <br>
... <br>
&lt;/ PStructuredGrid&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>°PPolyData&#8212; </b>ThePPolyData element specifies the number of ghost-levels by which the individual pieces overlap. <br>
The <tt>PPoints </tt>element describes the type of array used to specify the point locations, but does not actually contain <br>
the data. Each <tt>Piece </tt>element specifies the file in which the piece is stored. <br>
</p><p>
<tt>&lt;VTKFile type=" PPolyData" ...&gt; <br>
&lt;PPolyData GhostLevel="#"&gt; <br>
&lt;PPointData&gt;...&lt;/ PPointData&gt; <br>
&lt;PCellData&gt;...&lt;/ PCellData&gt; <br>
&lt;PPoints&gt;...&lt;/ PPoints&gt; <br>
&lt;Piece Source=" polyData0. vtp"/&gt; <br>
... <br>
&lt;/ PPolyData&gt; <br>
&lt;/ VTKFile&gt; <br>
</tt></p><p>
<b>° PUnstructuredGrid </b>&#8212;ThePUnstructuredGrid element specifies the number of ghost-levels by which the <br>
individual pieces overlap. The <tt>PPoints </tt>element describes the type of array used to specify the point locations, but <br>
does not actually contain the data. Each <tt>Piece </tt>element specifies the file in which the piece is stored. <br>
</p><p>
<tt>&lt;VTKFile type=" PUnstructuredGrid" ...&gt; <br>
&lt;PUnstructuredGrid GhostLevel=" 0"&gt; <br>
&lt;PPointData&gt;...&lt;/ PPointData&gt; <br>
&lt;PCellData&gt;...&lt;/ PCellData&gt; <br>
&lt;PPoints&gt;...&lt;/ PPoints&gt; <br>
&lt;Piece Source=" unstructuredGrid0. vtu"/&gt; <br>
... <br>
&lt;/ PUnstructuredGrid&gt; <br>
&lt;/ VTKFile&gt; </tt>
<br>
18 VTK 4. 2 File Formats <br>
Every dataset uses PPointData and PCellData elements to describe the types of data arrays associated with its points and <br>
cells. <br>
</p><p>
<b>°PPointDataand PCellData </b>&#8212; These elements simply mirror the <tt>PointData </tt>and <tt>CellData </tt>elements from the <br>
serial file formats. They contain <tt>PDataArray </tt>elements describing the data arrays, but without any actual data. <br>
</p><p>
<tt>&lt;PPointData Scalars=" Temperature" Vectors=" Velocity"&gt; <br>
&lt;PDataArray Name=" Velocity" .../&gt; <br>
&lt;PDataArray Name=" Temperature" .../&gt; <br>
&lt;PDataArray Name=" Pressure" .../&gt; <br>
&lt;/ PPointData&gt; <br>
</tt></p><p>
For datasets that need specification of points, the following elements mirror their counterparts from the serial file format: <br>
<b>°PPoints&#8212; </b>ThePPoints element contains one <tt>PDataArray </tt>element describing an array with three components. <br>
The data array does not actually contain any data. <br>
</p><p>
<tt>&lt;PPoints&gt; <br>
&lt;PDataArray NumberOfComponents=" 3" .../&gt; <br>
&lt;/ PPoints&gt; <br>
</tt></p><p>
<b>°PCoordinates&#8212; </b>ThePCoordinates element contains three <tt>PDataArray </tt>elements describing the arrays used to <br>
specify ordinates along each axis. The data arrays do not actually contain any data. <br>
</p><p>
<tt>&lt;PCoordinates&gt; <br>
&lt;PDataArray .../&gt; <br>
&lt;PDataArray .../&gt; <br>
&lt;PDataArray .../&gt; <br>
&lt;/ PCoordinates&gt; <br>
</tt></p><p>
All of the data and geometry specifications use <tt>PDataArray </tt>elements to describe the data array types: <br>
<b>° PDataArray </b>&#8212;ThePDataArray element specifies the <tt>type, Name, </tt>and optionally the <tt>NumberOfComponents <br>
</tt>attributes from the <tt>DataArray </tt>element. It does not contain the actual data. This can be used by readers to create the <br>
data array in their output without needing to read any real data, which is necessary for efficient pipeline updates in <br>
some cases. <br>
</p><p>
<tt>&lt;PDataArray type=" Float32" Name=" vectors" NumberOfComponents=" 3"/&gt; <br>
</tt><b>Example. </b>The following is a complete example specifying a <tt>vtkPolyData </tt>representing a cube with some scalar data on <br>
its points and faces. <br>
</p><p>
<tt>&lt;? xml version=" 1.0"?&gt; <br>
&lt;VTKFile type=" PPolyData" version=" 0.1" byte_ order=" LittleEndian"&gt; <br>
&lt;PPolyData GhostLevel=" 0"&gt; <br>
&lt;PPointData Scalars=" my_ scalars"&gt; <br>
&lt;PDataArray type=" Float32" Name=" my_ scalars"/&gt; <br>
&lt;/ PPointData&gt; <br>
&lt;PCellData Scalars=" cell_ scalars" Normals=" cell_ normals"&gt; <br>
&lt;PDataArray type=" Int32" Name=" cell_ scalars"/&gt; <br>
&lt;PDataArray type=" Float32" Name=" cell_ normals" NumberOfComponents=" 3"/&gt; <br>
&lt;/ PCellData&gt; <br>
&lt;PPoints&gt; <br>
&lt;PDataArray type=" Float32" NumberOfComponents=" 3"/&gt; <br>
&lt;/ PPoints&gt; <br>
&lt;Piece Source=" polyEx0. vtp"/&gt; <br>
&lt;/ PPolyData&gt; </tt>
<tt>&lt;/ VTKFile&gt; <br>
&lt;? xml version=" 1.0"?&gt; <br>
&lt;VTKFile type=" PolyData" version=" 0. 1" byte_ order=" LittleEndian"&gt; <br>
&lt;PolyData&gt; <br>
&lt;Piece NumberOfPoints=" 8" NumberOfVerts=" 0" NumberOfLines=" 0" <br>
NumberOfStrips=" 0" NumberOfPolys=" 6"&gt; <br>
&lt;Points&gt; <br>
&lt;DataArray type=" Float32" NumberOfComponents=" 3" format=" ascii"&gt; <br>
0 0 0 10 0 1 1 0 0 1 0 00 1 1 0 1 1 1 10 1 1 <br>
&lt;/ DataArray&gt; <br>
&lt;/ Points&gt; <br>
&lt;PointData Scalars=" my_ scalars"&gt; <br>
&lt;DataArray type=" Float32" Name=" my_ scalars" format=" ascii"&gt; <br>
0 1 2 34 5 6 7 <br>
&lt;/ DataArray&gt; <br>
&lt;/ PointData&gt; <br>
&lt;CellData Scalars=" cell_ scalars" Normals=" cell_ normals"&gt; <br>
&lt;DataArray type=" Int32" Name=" cell_ scalars" format=" ascii"&gt; <br>
0 1 2 34 5 <br>
&lt;/ DataArray&gt; <br>
&lt;DataArray type=" Float32" Name=" cell_ normals" <br>
NumberOfComponents=" 3" format=" ascii"&gt; <br>
0 0 -1 00 1 0 -1 0 0 1 0-1 0 0 1 0 0 <br>
&lt;/ DataArray&gt; <br>
&lt;/ CellData&gt; <br>
&lt;Polys&gt; <br>
&lt;DataArray type=" Int32" Name=" connectivity" format=" ascii"&gt; <br>
0 1 2 34 5 6 7 0 1 5 4 23 7 6 0 4 7 3 12 6 5 <br>
&lt;/ DataArray&gt; <br>
&lt;DataArray type=" Int32" Name=" offsets" format=" ascii"&gt; <br>
4 8 12 16 20 24 <br>
&lt;/ DataArray&gt; <br>
&lt;/ Polys&gt; <br>
&lt;/ Piece&gt; <br>
&lt;/ PolyData&gt; <br>
&lt;/ VTKFile&gt; </tt>
<br>
</dir>
</dir>
</body></html>
